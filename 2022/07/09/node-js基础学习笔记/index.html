<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>node.js基础学习笔记 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="####Node.js介绍 1.Node.js是一款使用Javascript语法作为基础的服务端开发技术 2.Node.js是一个javascript的运行环境,不是JS库也不是一种框架, 简单来说,node.JS可以解析和执行JS代码,使得曾今只能在浏览器执行的JS代码可以完全脱离浏览器  ##浏览器中的JS:    1.ECMAscript    2.BOM    3.DOM ##Node.j">
<meta property="og:type" content="article">
<meta property="og:title" content="node.js基础学习笔记">
<meta property="og:url" content="http://example.com/2022/07/09/node-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="####Node.js介绍 1.Node.js是一款使用Javascript语法作为基础的服务端开发技术 2.Node.js是一个javascript的运行环境,不是JS库也不是一种框架, 简单来说,node.JS可以解析和执行JS代码,使得曾今只能在浏览器执行的JS代码可以完全脱离浏览器  ##浏览器中的JS:    1.ECMAscript    2.BOM    3.DOM ##Node.j">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-07-09T11:50:45.000Z">
<meta property="article:modified_time" content="2022-07-09T11:51:03.213Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-node-js基础学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/07/09/node-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-07-09T11:50:45.000Z" itemprop="datePublished">2022-07-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      node.js基础学习笔记
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>####Node.js介绍</p>
<pre><code>1.Node.js是一款使用Javascript语法作为基础的服务端开发技术
2.Node.js是一个javascript的运行环境,不是JS库也不是一种框架,
简单来说,node.JS可以解析和执行JS代码,使得曾今只能在浏览器执行的JS代码可以完全脱离浏览器
</code></pre>
<p>##浏览器中的JS:<br>    1.ECMAscript<br>    2.BOM<br>    3.DOM</p>
<p>##Node.js中的JS:<br>    1.ECMAscript<br>    2.没有BOM,DOM,<br>        在Node.js的执行环境中为JS提供了一些服务端级别的操作API列如:<br>        文件的读写,网络服务的构建,网络通信,http服务器…<br>        也就是说在node.js的Javascript运行环境中,可以完全使用ECMAscript标准中的JS语法<br>        但是无法像浏览器中的Javascript一样直接去操作DOM文档,操作我们的浏览器,<br>        而是完全剑指服务器端编程的一门技术,<br>        在学习Node.js中主要就是需要学会使用Node.JS提供的操作服务器的API</p>
<p>##Node.js的特点:<br>    1.event-driven 事件驱动<br>    2.non-blocking I&#x2F;O model 非阻塞IO模型 (异步)<br>    3.lightweight and efficient 轻量与高效</p>
<p>###npm介绍:<br>    1.npm是世界上最大的使用Node.js开发开源生态系统,<br>        在以往开发人员使用Javascript相关的第三方插件或者包,<br>        需要手动下载插件代码,引入到我们的JS文件中,<br>        而npm平台则集成了绝大多数的JavaScript相关的插件包,<br>        这样做的目的是为了使开发人员更加方便快捷的下载和使用,<br>        开发人员只需要一句命令就可以使用指定的插件<br>        如:npm install jquery<br>        [使用jqueryJS插件库]</p>
<p>##node.js可以用于开发<br>        web服务器后台<br>        命令行工具:<br>            npm<br>            git<br>            hexo<br>        对于前端开发工程师来讲,接触Node更多的是使用命令行工具</p>
<p>##简单的命令行操作:<br>        .cd 返回上级<br>        .dir 列出目录<br>        .ls 列出目录<br>        .mkdir 创建目录<br>        .rm 删除目录</p>
<p>参考资源:<br>        1.深入浅出Node.js<br>        2.Node.js权威指南<br>        3.JavaScript标准参考教程:<a target="_blank" rel="noopener" href="http://javascript.ruanyifeng.com/">http://javascript.ruanyifeng.com</a><br>        4.Node入门:<a target="_blank" rel="noopener" href="http://www.nodebeginner.org/index-zh-cn.html">http://www.nodebeginner.org/index-zh-cn.html</a><br>        5.官方API文档:<a target="_blank" rel="noopener" href="http://www.node.jsogr/dist/latest-v6.x/docs/api/">http://www.node.jsogr/dist/latest-v6.x/docs/api/</a><br>        6.中文文档:<a target="_blank" rel="noopener" href="http://www.nodeclass.com/api/node.html">http://www.nodeclass.com/api/node.html</a><br>        7.cnode社区:<a target="_blank" rel="noopener" href="http://cnodejs.org/">http://cnodejs.org</a><br>        8.cnode-新手入门:<a target="_blank" rel="noopener" href="http://cnodejs.org/getstart">http://cnodejs.org/getstart</a></p>
<p>​		<br>学习目标:<br>        1.B\S编程模型<br>            Browser-Server 浏览器服务器编程模型<br>            back-end	   服务端开发技术<br>            任何服务端技术在对于B\S编程模型上都是一样的,和语言无关<br>        2.模块化编程:<br>            RequireJS<br>            SeaJS<br>            在以往认知的JS只能通过SCRIPT标签来加载执行<br>            在Node中可以像引入CSS文件一样通过引用的方式来加载Javascript脚本文件<br>        3.Node常用API:</p>
<pre><code>    4.异步编程
        回调函数
        Promise
        async
        generator
    5.Express Web 开发框架
    
    6.Ecmascript6
        一个javascript的新语法
    总结 通过学习node 了解到服务端编程,服务端业务,
    前后端的开发配合,前端接口的开发编写,
    同时为前端进阶技术如:Vue.js,React,angular 
    等前端高级技术的知识.
</code></pre>
<p>​		<br>​		<br>​		<br>​		<br>###安装Node:<br>    下载地址node.js.org&#x2F;en&#x2F;download&#x2F;</p>
<pre><code>1.安装:
    一直点next就完了
    对于已安装过的,重新安装会覆盖旧版本

2.确认node环境是否安装成功:
    打开命令行,输入node --version
    或者node-v

3.环境变量:	
</code></pre>
<p>​	<br>##使用node执行JS代码<br>    1.创建编写JS脚本文件<br>    2.打开CMD终端,定位到脚本文件所在目录,可以通过CD切换至文件所在目录,或者在文件目录中按住shift+右键,在命令窗口打开.<br>    3.输入node+空格+文件名执行对应的文件<br>    注意:文件名不能使用node.js命名,<br>        且最好不要使用中文作为文件名<br>        在node.js文件中不要使用DOM与BOM等浏览器API操作代码<br>        会导致程序报错,因为在node环境中没有DOM与BOM的概念</p>
<pre><code>4.解析执行javascript

5.读写文件
  浏览器解析执行的JS代码无法操作文件
  但是在Node环境中的JS是具备操作文件的能力
</code></pre>
<h2 id="5-1-file-system文件系统"><a href="#5-1-file-system文件系统" class="headerlink" title="5.1.file-system文件系统:"></a>5.1.file-system文件系统:</h2><pre><code>  fs是file-system的简写
  在node中如果想要进行文件操作,就必须引入fs这个核心模块
  在fs这个核心模块中,就提供了所有的文件操作相关的API和方法
  列如:
  读取文件:
  var fs=require(&#39;fs&#39;)  使用require方法加载fs核心模块
                        该模块提供了很多强大的文件操作方法
  fs.readFile(&quot;读取的文件路径&quot;,&quot;回调函数&quot;) 读取文件
  readFile方法的第一个参数就是需要读取的文件的路径,
  参数二是一个回调函数,
  回调函数需要两个参数:
    error:
        如果文件读取成功,那么error就是null
        如果文件读取失败,那么error保存的就是错误对象信息
    data:
        如果文件读取成功,那么data保存的就是读到的数据
        如果文件读取失败,那么error保存的就是错误对象信息
    注意,此方法获取的文件数据获取的数据默认为2进制数据,
    但是node会自动帮我们转换为16进制的数据格式,
    可以通过date.tostring方法让数据格式成为我们日常的数据格式
    
    编写文件(创建文件):
    var fs=require(&#39;fs&#39;);
    fs.writeFile(&quot;文件路径/文件名文件格式&quot;,&#39;需要写入的文件内容&#39;,回调函数);
    参数1为文件路径以及文件名称与格式,
    参数2为写入文件的内容,
    参数三为回调函数,writeFile中的回调函数只需要一个参数error,
    这个参数就是错误对象,若文件写入成功则error等于null
    由于node.js是异步的,
    所以几乎所有方法都需要回调函数
</code></pre>
<h2 id="6-http"><a href="#6-http" class="headerlink" title="6.http"></a>6.http</h2><pre><code>    使用node可以非常轻松的构建一个web服务器
    在node中提供了一个http的核心模块;
    这个模块的用途就是用来操作和构建web服务器
    1.加载http核心模块:
    var http = require(&#39;http&#39;); 变量名可以随便取
    
    2.使用http.createServer()方法创建一个web服务器
    var server=http.createServer()	返回一个server服务器对象实例
    
    3.使用服务器提供对数据的服务:
    服务器的服务流程:
    
    2.接受用户端传回的请求数据
    3.处理请求
    4.将处理好的结果反馈给客户端
    
    1.发送请求:
    server.on(&quot;request&quot;,function()&#123;
            console.log(&quot;收到&quot;)
    &#125;)
    通过创建的server服务器对象,
    调用node.js htttp核心模块中的服务器交互事件的方法,
    参数一为事件的类型,参数二为请求后的回调函数
    request请求
    
    2.绑定端口号,启动服务器
    我们的服务器主要用于网络通信,
    而只要是网络通信,就必然会有端口号
    
    server.listen(3000,function()&#123;
    console.log(&#39;服务器启动成功,可以通过http://127.0.0.1:3000/来进行访问&#39;)
    &#125;)
    通过server.listen方法绑定一个端口号,
    参数1为需要绑定的端口号,参数2为回调函数.
    当服务器启动成功就会执行回调函数
    在终端执行代码成功后,终端没有关闭,则表示服务器启动成功了,
    启动成功后进行操作无效r
</code></pre>
<p>​		<br>        3.处理请求事件函数需要两个参数分别是:</p>
<pre><code>    request请求对象
        请求对象可以用来获取客户端的一些请求信息,列如请求路径
    
    response响应对象	
        响应对象可以用来给客户端返回响应消息
        
        server.on(&quot;request&quot;,function(request,response)&#123;
                 console.log(&#39;收到请求,请求路径是&#39;+request.url)
        &#125;)
        
        request.url,就是客户的请求路径,
        客户的请求路径就是在浏览器中的网址输入栏末尾的/后面的文件路径
        列如:http://127.0.0.1 :3000/a/b/c/d
        其中/a/b/c/d就是请求的路径
        
    4.服务器响应客户端:
        在onrequest请求对象中的回调函数中的response对象,
        有一个方法:write 可以给客户端发送响应数据,
        write方法可以使用多次,但是在最后一定要使用end来结束响应,
        否则客户端会一直等待服务器的响应
        格式如下:
        server.on(&quot;request&quot;,function(request,response)&#123;
                 console.log(&#39;收到请求,请求路径是&#39;+request.url)
                 reponse.write(&#39;hello&#39;)  参数为需要返回给客户端的数据
                 reponse.write(&#39;nodejs&#39;) write方法可以使用多次
                                         write方法返回的数据只能是字符串或者2进制数据
                                         且返回中文会乱码
                 reponse.end();			 告诉客户端数据发送完毕,若reponse.end(&#39;hello&#39;)里加参数,则返回数据并结束	
        &#125;)	
        但是现在的服务器依然很弱,
        无法针对不同的请求返回不同的处理数据,
        也就是说无论请求数据是什么,
        最后返回的都是response.write中的数据,
        如果希望能针对不同的数据请求返回不同的数据,
        可以通过判断resquest.url中的url(统一资源定位符)地址
        来判断应该返回什么数据列如:
        server.on(&quot;requset&quot;,function(requset,response)
            console.log(&#39;true&#39;+request.url);
            var url=requset.url;  
        
            [注]requset获取到的是端口号后面的请求路径,
            且所有的请求路径就是以/开头
            
            if(url===&quot;/&quot;)&#123;
                response.write(&quot;index page&quot;);
                response.end();
            &#125;else if(url=&quot;/loging&quot;)&#123;
                response.write(&quot;登录&quot;);
                response.end();
            &#125;else&#123;
                response.end(&#39;404 Not Found&#39;)
            &#125;
            
        )
        总结:使用node.js中的http模块创建简单web服务器分为以下几步:
        1.加载http核心模块
        var http=require(&quot;http&quot;);
        2.创建server
        var server=createServer();
        3.监听绑定客户端请求数据事件:
        server.on(&#39;requset&#39;,function(requset,response)&#123;
            console.log(requset.url)  输出请求路径
        &#125;)
        4.绑定端口号,启动服务器
        server.listen(3000,function()&#123;
            console.log(&#39;服务器启动成功&#39;)
        &#125;)
</code></pre>
<p>#解决中文乱码setHeader:<br>            res.setHeader(“content-type”,’text&#x2F;plain; charset&#x3D;utf-8’)<br>              这段参数必须按照此格式来写,<br>              参数一<br>              表示指定响应内容的数据类型,</p>
<pre><code>          参数二
          表示类型为文本数据/表示是什么类型的文本
          plain表示普通文本
          html表示html文本,若设置为html文本则,
          浏览器会将文本的内容解析为html代码
          
            
          参数三
          声明指定的字符编码 一般都是utf-8;
          总之此方法就是告诉浏览器,我们响应数据的编码格式
          res.end(&#39;hello 世界&#39;)
          服务器在响应内容中带有中文的时候无法正确解析,
          因为在服务器默认发送的数据,
          其实是utf-8的编码格式,
          但是浏览器不知道你是utf-8编码的内容,
          所以浏览器会采用操作系统默认的编码去解析,
          中文操作系统的默认编码格式为gbk
          解决方法:
          告诉浏览器我们发送的数据是什么编码格式
          语法如下:
        
</code></pre>
<p>​		<br>##Node中的核心模块以及模块概念:<br>#		1.在node中没有全局块级作用域的概念,只有模块作用域<br>#		在node.js中模块分为三种,<br>#		1.具名的核心模块,列如fs,http<br>#	    2.用户自己编写的文集模块<br>            可以理解为,每个单独的需要执行Node的JS文件是一个模块,<br>            每个模块有单独的作用域,也就是说,各个模块中的代码,<br>            在不通过require挂载到另一个模块的情况下,<br>            各个模块间是毫无关联的,所以不管是,<br>            重复的变量名还是函数名都不会发生冲突,<br>            也无法进行跨模块使用,<br>            但是在node.js中提供了一个require方法来加载执行使用外部模块,<br>            但是依然无法使用外部模块的变量,还有函数<br>            简单的模块化:<br>            文件a.js:<br>            var a&#x3D;’hello’;<br>            console.log(‘a’)<br>            文件b.js{<br>            var b&#x3D;’node.js’;<br>            require(“a.js”)	<br>            console.log(‘b’);		<br>            通过require加载外部模块时,参数为指定模块的路径<br>            若是相对路径,则必须加.&#x2F;</p>
<pre><code>        [若在此处调用文件a.js中的a变量,输出结果则为undefined]
        
        &#125;
        以上代码,在b.js模块中加载执行了a.js模块,
        执行顺序自上向下
        打印结果为 hello node.js
        require方法不仅可以加载核心模块,
        还可以加载用户自己编写的文件模块
        但是即使是加载了外部模块文件,
        两个模块之间的变量依然不会发生冲突
        模块之间的变量依然无法互相调用,
        外部访问不到内部,内部也访问不到外部
</code></pre>
<p>​			<br>            但是在开发中,我们往往希望在加载其他模块的同时,<br>            还可以使用该模块中的数据和方法<br>            在node.js中有方法可以实现模块之间数据的通信,和方法的调用</p>
<p>​			<br>            require方法有两个作用;<br>            1.加载文件模块并执行里面的代码<br>            2.拿到被加载文件导出的接口对象,<br>            在每个文件模块中都提供了一个exports对象<br>            exports默认是一个空对象,<br>            exports对象可以保存需要导出的模块变量和方法,<br>            并保存到require对象中,将require对象赋值给一个变量,<br>            则可以通过该变量调用被加载的模块中,<br>            挂载到exports对象中的数据,和方法<br>            用于加载文件的require对象可以使用exports对象,<br>            可以理解为exports对象是require对象的一部分</p>
<pre><code>    代码演示:
        文件模块a:

        var ret = require(&#39;./b&#39;);		
        console.log(&#39;im a&#39;);
        console.log(ret.sum(20,10)); 通过require对象的管理者ret,
                                     调用exports对象中挂载的sum方法
        console.log(ret.str);
</code></pre>
<p>​			<br>            文件模块b:</p>
<pre><code>        exports.sum=function(x,y)&#123;  将sum方法挂载到exports对象中
            return x+y;
        &#125;
        exports.str=&quot;不要回答&quot;		将str字符串挂载到exports对象中
        console.log(&#39;im b&#39;)
</code></pre>
<h1 id="2-node-js核心模块"><a href="#2-node-js核心模块" class="headerlink" title="2.node.js核心模块:"></a>2.node.js核心模块:</h1><pre><code>        node为JavaScript提供了很多服务器级别的API,
        这些API绝大多是都包装到了一个具名的核心模块中,
        列如文件操作的fs核心模块,http服务器构建模块,
        Path路径操作模块,os操作系统模块....
        在开发中,只要遇到有核心模块的概念,就应该马上想到,
        如果需要使用这个模块,就必须加载模块,例如:
        
        var fs = require(&#39;fs&#39;);		加载文件操作模块
        
        var http = require(&#39;http&#39;); 加载web服务模块
        
        var os=require(&quot;os&quot;);		加载操作系统模块
        
        console.log(os.cpus());  	输出当前设备CPU信息
        console.log(os.totalmem()/1024) 返回当前设备内存大小
        
        node中类似的API非常多,可以上官方文档去查询.
</code></pre>
<p>​			<br>​			</p>
<h1 id="端口号概念"><a href="#端口号概念" class="headerlink" title="端口号概念:"></a>端口号概念:</h1><pre><code>        所有联网的程序都需要进行网络通信
        一台计算机中只有一个物理网卡,而且同一个局域网中,
        网卡的地址必须是唯一的,
        网卡是通过唯一的ip地址来进行定位的.
        在我们在我们浏览网页时输入的网址,
        如www.baidu.com并不是实际的网页地址,
        真正的网址是在经过DNS解析后的web服务器的ip地址,
        服务器就是一台24小时开机用于处理数据通信的计算机,
        而所有的计算机在进行网络通信的时候都需要ip地址进行定位,
        服务器便可以通过我们的ip地址将数据返回到我们的计算机上.
        但是在进行网络通信的时候,往往是通过软件进行数据通信,
        列如qq,微信,浏览器,在这些软件接受数据的时候,
        web服务器会通过软件独有的端口号来定位具体的应用程序,
        也就是说服务器在返回数据时,可以通过我们计算机的ip地址,
        精确的定位到我们的计算机,
        但是这些数据无法通过ip地址精确的返回到我们的软件上,
        因此所有需要进行网络通信的软件都应该有独立分配的端口号,
        以便于数据可以通过识别端口号精确的将数据发送到我们的软件上
        若没有端口号,则无法通信
        总的来说就是IP地址用来定位计算机,而端口号用来定位我们的具体的应用程序软件
        所以需要进行网络通信的应用程序都需要端口号.
        [注]浏览器的默认端口是80
        列如:
        QQ的端口是5000 那么qq只会接受对应的端口的数据
        端口号的范围在0-65536之间
        扩展:
        在命令行查看本机ip地址输入ipconfig 列表中的ipv4地址就是本机的ip地址
        ctrl+c重启控制台
        
        
        开启node.js的web服务器的时候,可以同时开启多个,但是前提是端口号互不冲突
        在同一台计算机中,同一个端口号,同一个时间,只能被一个应用程序占有	
</code></pre>
<p>​</p>
<p>###使服务器响应并返回发送html页面以及各类文件方法:</p>
<pre><code>        res.end(&#39;hello 世界&#39;)
        服务器在响应内容中带有中文的时候无法正确解析,
        因为在服务器默认发送的数据,
        其实是utf-8的编码格式,
        但是浏览器不知道你是utf-8编码的内容,
        所以浏览器会采用操作系统默认的编码去解析,
        中文操作系统的默认编码格式为gbk
        解决方法:
        告诉浏览器我们发送的数据是什么编码格式
        语法如下:
        res.setHeader(&quot;content-type&quot;,&#39;text/plain; charset=utf-8&#39;)
        这段参数必须按照此格式来写,
        参数一表示指定响应内容的数据类型,
        参数二表示类型为文本数据,
        参数三声明指定的字符编码 一般都是utf-8;
        Conten-Type在http协议中就是用来告知对方,
        我发送过来的数据是什么类型的数据
        常见类型有:
        text/plain  普通文本类型
        text/html   html文件
    
    
</code></pre>
<p>##11.29总结:<br>    node是什么:<br>        1.JavaScript运行环境<br>        2.既不是语言也不是框架,node是一个平台<br>    node.js中的JavaScript:<br>        1.没有BOM,DOM<br>        2.ECMASCript基本的JavaScript语言部分<br>        3.学会node就是学会操作node.js中提供的服务器级别的API</p>
<pre><code>node中的模块系统
    在node中没有全局作用域的概念
    在node中,只能通过require方法来加载执行多个JavaScript脚本文件
    require加载只能是执行其中的代码,文件与文件之间由于是模块作用域,
    所以不会污染彼此的作用域
    模块式完全封闭的
    外部无法访问内部
    内部也无法访问外部

模块作用域的好处
     但是在某些情况下,模块与模块之间是需要进行通信的
    在每个模块中都提供了exports对象
    该对象默认是一个空对象
    我们要做的就是把需要被外部访问的使用的模块成员手动的挂载到&#39;exports&#39;接口对象中
    然后谁加载(&#39;require&#39;)这个模块,谁可以得到模块内部的exports接口对象

核心模块:
    核心模块是由node提供的一个个具名的模块,他们都有自己特殊的名称标识,
    列如:
        fs 文件操作模块
        http 网络服务构建模块
        os 操作系统信息模块
        path 路径处理模块
    所有核心模型在使用的时候都必须手动先使用&#39;require&#39;方法来加载,然后才可以使用

content-type
    服务器最好把每次响应的数据是什么内容类型都告诉客户端,而且要正常告诉
    不同的资源对应的conten-type都不一样,具体参照tool.oschina.net
    对于文本类型的诗句,最好都加上编码,目的是为了防止中文解析乱码问题

通过网络发送文件
    发送的并不是文件,本质上来讲发送的是文件的内容
    当浏览器收到服务器响应的内容之后,就会根据你的conten-type进行对应的解析处理

服务器请求事件:
    一个请求对应一个响应,如果在一个请求过程中,已经结束响应了,则能重复发送响应.
    可以通过直接return res.end(&#39;In the end&#39;) 来直接结束响应

读取文件目录:
    fs.readdir(wwwDir文件路径,function(err错误信息,files需要		读取的文件路径)回调函数&#123;
        if(err)&#123;
            console.log(&quot;文件读取失败&quot;)文件读取失败执行
        &#125;else&#123;
            console.log(files)文件读取成功执行
        &#125;
    &#125;);
    返回参数的是一个保存文件路径的数组 
在ECMAscript6中的`字符串中,可以使用$&#123;变量名&#125;来引用变量`


读取文件:
fs.readFile(&#39;文件路径&#39;,function(err,data)&#123;
    读取到的文件会保存在data中,且文件格式是二进制数据
    读取到的错误信息会保存在err中
    if(err)&#123;
        console.log(文件读取失败)
    &#125;else&#123;
        console.log(文件读取成功+data)
        &#125;
    将读取到的文件数据转换为字符串格式,使用data.toString()方法	
    读取的文件字符串可以进行解析替换,使用data.replace(&#39;data&#39;,&#39;holo world&#39;)方法,将data替换为Holor world;
&#125;	
    
    
    
    
    
</code></pre>
<p>##在node中使用模板引擎:<br>        art-template 不仅可以在浏览器使用,也可在服务端使用<br>        模板引擎最早就是诞生在服务端</p>
<pre><code>    安装: npm install art-template
    该命令在哪一文件目录下执行,就会把插件包下载安装到该文件目录下,默认会下载到node_modules目录中
    在浏览器中需要引用node_modules/art-template/lib/template-web.js
    使用方法:
    
    1.引入template插件
     &lt;script src=&quot;node_modules/art-template/lib/template-web.js&quot;&gt;&lt;/script&gt;
    2.使用并定于模板 
     &lt;script type = &quot;text/template&quot; id = &#39;tpl&#39;&gt;
        hello&#123;&#123;name&#125;&#125;
        age&#123;&#123;age&#125;&#125;岁
        form&#123;&#123;province&#125;&#125;
        I like:&#123;&#123;each hobbies&#125;&#125; &#123;&#123; $value &#125;&#125; &#123;&#123;/each&#125;&#125;
    &lt;/script&gt;	
    
    3.定义数据
    &lt;script&gt;
    var ret = template(&quot;tpl&quot;,&#123;
        name : &quot;jack&quot;,
        age : 18,
        province:&#39;湖南&#39;,
        hobbies:[
            &quot;唱&quot;,
            &quot;跳&quot;,
            &quot;rap&quot;,
            &quot;篮球&quot;
        ]
    &#125;)
    注意 模板引擎不关心你的字符串内容,只关心自己能识别的模板标记语法
    
    
    在node.js中只需要使用require方法加载art-template模块即可:
    参数就是isntall的插件包名字
    var template = require(&quot;art-template&quot;)
    var ret=template = render(&#39;hello&#123;&#123;name&#125;&#125;&#39;,&#123;
        name:&#39;jack&#39;;
    &#125;)
    console.log(ret);
template还可以将字符替换到html页面中,但是需要在html标签中预留一个特殊的标识字符,方便模板引擎查找
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/07/09/node-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="cl5dttb5t0001sogt7w6pcz9d" data-title="node.js基础学习笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2022/07/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">我的第一篇博客</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/07/09/node-js%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">node.js基础学习笔记</a>
          </li>
        
          <li>
            <a href="/2022/07/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/">我的第一篇博客</a>
          </li>
        
          <li>
            <a href="/2022/07/09/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>